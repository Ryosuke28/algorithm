# 深さ優先探索
深さ優先探索(Depth First Search: DFS)は、可能な限り隣接する頂点を訪問するという戦略に基づく<br>
グラフの探索アルゴリズム。<br>
未探索の接続辺が残されている頂点の中で、最後に発見した頂点vの接続辺を再帰的に探索する。<br>
vの辺を全て探索し終えると、vを発見した時に通ってきた辺を後戻りして探索を続行する。<br>
探索は元の始点から到達可能な全ての頂点を発見するまで続き、未発見の頂点が残っていれば、<br>
その中の番号が一番小さい1つを新たな始点として探索を続ける。<br>

# 解説
深さ優先探索では、スタックを用いて「まだ探索中の頂点」を一時的に保持しておく。<br>
スタックを用いた深さ優先探索は次のようなアルゴリズムになる。<br>

1. 一番最初に訪問する頂点をスタックに入れる。
2. スタックに頂点が積まれている限り、以下の処理を繰り返す。
 - スタックのトップにある頂点uを訪問する。
 - 現在訪問中の頂点uから次の頂点vへ移動するときにvをスタックに積む。<br>
   ただし、現在訪問中の頂点uに未訪問の隣接する頂点がなければuをスタックから削除する。<br>


# コード解説
コードファイルでは2種類の解法を実装している。<br>
- calc_stack : スタックを用いた解法
- dfs_recursive : 再帰処理を用いた解法

どちらも共通して以下の配列を使用している<br>
V: 各頂点の隣接する頂点番号を記録している配列<br>
D: 各頂点の発見時刻<br>
F: 各頂点の探索終了時刻<br>

スタックを用いた解法の方が、深さ優先探索について理解しやすいように感じるが、処理としては再帰を用いた方法の方がシンプルになる。<br>

## calc_stack
解説通り、スタックを使用した解法。以下のような手順で探索する。<br>
1. 一番最初に訪問する頂点をスタックに入れ、発見時間を記録する。
2. スタックが空になるまで、以下の処理を繰り返す。
 - スタックのトップにある頂点uを訪問する。
 - 頂点uの隣接する頂点のうち、idの最も小さいものを頂点vとしてスタックに積む。<br>
   ただし、頂点uに未訪問の隣接する頂点がなければ、探索終了時間を記録しuをスタックから削除する。<br>

## dfs_recursive
再帰処理を使用した実装。全ての頂点に対して、id順に以下の処理を行う。<br>
1. 頂点uが未訪問の場合、発見時間を記録する。
2. 頂点uの隣接する未訪問の各頂点に対してdfs_recursiveを行う。
3. 隣接する全ての頂点に対してdfs_recursiveが完了すれば、頂点uの探索終了時間を記録する。
