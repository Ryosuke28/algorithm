# 全探索
与えられた数列Aのいくつかの要素を足し合わせてmが作れるかどうかを判定する<br>
この問題は数列Aの最大数が20と小さいため、全パターンの組み合わせを列挙するアルゴリズムが適用できる。<br>
Aの各要素を選択するかしないかの2択となるため、O(2^n)のアルゴリズムで実装できる。<br>

## 組み合わせの作成
要素数がnの配列から作れる全ての組み合わせを列挙するアルゴリズムは、再帰関数を利用して以下のように書ける。<br>
```
make_combination()
  for i が 0　から n-1 まで
    S[i] = 0 # 組み合わせの配列Sを初期化
  rec(0)

rec(i)
  if i が n に達した
    print S
    return
  rec(i+1)
  S[i] = 1 # iを選択する
  rec(i+1)
  s[i] = 0 # iを選択しない
```

SをS[i]が1のときAのi番目の整数を選択することを示す配列とする。<br>
rec内の1つ目の`rec(i+1)`はS[i]=0(i番目を選択する)、2つ目の`rec(i+1)`はS[i]=1(i番目を選択する)として再帰還数によって分岐させ、<br>
iがnに達した時のSが1つの組み合わせを表す。<br>

2^n -1の数の組み合わせが出力されることになり、n=3の場合、{0,0,0},{0,0,1},{0,1,0},{0,1,1},{1,0,0},{1,0,1},{1,1,0},{1,1,1}<br>
の8通りの組み合わせが順番に出力される。<br>

## 問題の解法
解答では上記の考え方を応用し、次のような1つの関数を定義して問題を解く。<br>
`solve(i,m)`を、「i番目以降の要素を使用してmを作れる場合、trueを返す」という関数とすると、<br>
`solve(i,m)`はより小さい部分である`solve(i+1,m)`と`solve(i+1,m-A[i])`に分割できる。<br>
この場合、mからA[i]を引いている部分がA[i]を使うことに相当する。これらを再帰的に調べることで、元の問題である`solve(0,m)`を判定できる。<br>

```
solve(i, m)
  if m == 0
    return true
  if i >= n
    return false
  res = solve(i + 1, m) || solve(i + 1, m - A[i])
  return res
```

mが0になったとき、与えられた整数を作ることができたことになる。<br>
mが0にならないままiがnに達したなら、与えられた整数を作れなかったことになる。<br>
部分問題である`solve(i + 1, m)`または`solve(i + 1, m - A[i])`のいずれかがtrueとなるとき、元の問題`solve(i,m)`がtrueとなる。<br>

このように再帰関数内で2つの再帰関数を呼び出すことを繰り返せば、O(2^n)のアルゴリズムとなる。<br>
nが大きい場合計算量が莫大なものになるため、全ての組み合わせを調べる方法は適用することができない。<br>